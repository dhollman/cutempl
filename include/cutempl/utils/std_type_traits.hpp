#pragma once

#include "cutempl/utils/as_metafunction_class.hpp"

namespace cutempl::stdmfc {

using is_void_mfc = as_metafunction_class<std::is_void>;
using is_null_pointer_mfc = as_metafunction_class<std::is_null_pointer>;
using is_integral_mfc = as_metafunction_class<std::is_integral>;
using is_floating_point_mfc = as_metafunction_class<std::is_floating_point>;
using is_array_mfc = as_metafunction_class<std::is_array>;
using is_enum_mfc = as_metafunction_class<std::is_enum>;
using is_union_mfc = as_metafunction_class<std::is_union>;
using is_class_mfc = as_metafunction_class<std::is_class>;
using is_function_mfc = as_metafunction_class<std::is_function>;
using is_pointer_mfc = as_metafunction_class<std::is_pointer>;
using is_lvalue_reference_mfc = as_metafunction_class<std::is_lvalue_reference>;
using is_rvalue_reference_mfc = as_metafunction_class<std::is_rvalue_reference>;
using is_member_object_pointer_mfc = as_metafunction_class<std::is_member_object_pointer>;
using is_member_function_pointer_mfc = as_metafunction_class<std::is_member_function_pointer>;
using is_fundamental_mfc = as_metafunction_class<std::is_fundamental>;
using is_arithmetic_mfc = as_metafunction_class<std::is_arithmetic>;
using is_scalar_mfc = as_metafunction_class<std::is_scalar>;
using is_object_mfc = as_metafunction_class<std::is_object>;
using is_compound_mfc = as_metafunction_class<std::is_compound>;
using is_reference_mfc = as_metafunction_class<std::is_reference>;
using is_member_pointer_mfc = as_metafunction_class<std::is_member_pointer>;
using is_const_mfc = as_metafunction_class<std::is_const>;
using is_volatile_mfc = as_metafunction_class<std::is_volatile>;
using is_trivial_mfc = as_metafunction_class<std::is_trivial>;
using is_trivially_copyable_mfc = as_metafunction_class<std::is_trivially_copyable>;
using is_standard_layout_mfc = as_metafunction_class<std::is_standard_layout>;
using has_unique_object_representations_mfc = as_metafunction_class<std::has_unique_object_representations>;
using is_empty_mfc = as_metafunction_class<std::is_empty>;
using is_polymorphic_mfc = as_metafunction_class<std::is_polymorphic>;
using is_abstract_mfc = as_metafunction_class<std::is_abstract>;
using is_final_mfc = as_metafunction_class<std::is_final>;
using is_aggregate_mfc = as_metafunction_class<std::is_aggregate>;
using is_signed_mfc = as_metafunction_class<std::is_signed>;
using is_unsigned_mfc = as_metafunction_class<std::is_unsigned>;
using is_bounded_array_mfc = as_metafunction_class<std::is_bounded_array>;
using is_unbounded_array_mfc = as_metafunction_class<std::is_unbounded_array>;
using is_constructible_mfc = as_metafunction_class<std::is_constructible>;
using is_trivially_constructible_mfc = as_metafunction_class<std::is_trivially_constructible>;
using is_nothrow_constructible_mfc = as_metafunction_class<std::is_nothrow_constructible>;
using is_default_constructible_mfc = as_metafunction_class<std::is_default_constructible>;
using is_trivially_default_constructible_mfc = as_metafunction_class<std::is_trivially_default_constructible>;
using is_nothrow_default_constructible_mfc = as_metafunction_class<std::is_nothrow_default_constructible>;
using is_copy_constructible_mfc = as_metafunction_class<std::is_copy_constructible>;
using is_trivially_copy_constructible_mfc = as_metafunction_class<std::is_trivially_copy_constructible>;
using is_nothrow_copy_constructible_mfc = as_metafunction_class<std::is_nothrow_copy_constructible>;
using is_move_constructible_mfc = as_metafunction_class<std::is_move_constructible>;
using is_trivially_move_constructible_mfc = as_metafunction_class<std::is_trivially_move_constructible>;
using is_nothrow_move_constructible_mfc = as_metafunction_class<std::is_nothrow_move_constructible>;
using is_assignable_mfc = as_metafunction_class<std::is_assignable>;
using is_trivially_assignable_mfc = as_metafunction_class<std::is_trivially_assignable>;
using is_nothrow_assignable_mfc = as_metafunction_class<std::is_nothrow_assignable>;
using is_copy_assignable_mfc = as_metafunction_class<std::is_copy_assignable>;
using is_trivially_copy_assignable_mfc = as_metafunction_class<std::is_trivially_copy_assignable>;
using is_nothrow_copy_assignable_mfc = as_metafunction_class<std::is_nothrow_copy_assignable>;
using is_move_assignable_mfc = as_metafunction_class<std::is_move_assignable>;
using is_trivially_move_assignable_mfc = as_metafunction_class<std::is_trivially_move_assignable>;
using is_nothrow_move_assignable_mfc = as_metafunction_class<std::is_nothrow_move_assignable>;
using is_destructible_mfc = as_metafunction_class<std::is_destructible>;
using is_trivially_destructible_mfc = as_metafunction_class<std::is_trivially_destructible>;
using is_nothrow_destructible_mfc = as_metafunction_class<std::is_nothrow_destructible>;
using has_virtual_destructor_mfc = as_metafunction_class<std::has_virtual_destructor>;
using is_swappable_with_mfc = as_metafunction_class<std::is_swappable_with>;
using is_swappable_mfc = as_metafunction_class<std::is_swappable>;
using is_nothrow_swappable_with_mfc = as_metafunction_class<std::is_nothrow_swappable_with>;
using is_nothrow_swappable_mfc = as_metafunction_class<std::is_nothrow_swappable>;
using alignment_of_mfc = as_metafunction_class<std::alignment_of>;
using rank_mfc = as_metafunction_class<std::rank>;
using is_same_mfc = as_metafunction_class<std::is_same>;
using is_base_of_mfc = as_metafunction_class<std::is_base_of>;
using is_convertible_mfc = as_metafunction_class<std::is_convertible>;
using is_nothrow_convertible_mfc = as_metafunction_class<std::is_nothrow_convertible>;
using is_invocable_mfc = as_metafunction_class<std::is_invocable>;
using is_invocable_r_mfc = as_metafunction_class<std::is_invocable_r>;
using is_nothrow_invocable_mfc = as_metafunction_class<std::is_nothrow_invocable>;
using is_nothrow_invocable_r_mfc = as_metafunction_class<std::is_nothrow_invocable_r>;
using remove_cv_mfc = as_metafunction_class<std::remove_cv>;
using remove_const_mfc = as_metafunction_class<std::remove_const>;
using remove_volatile_mfc = as_metafunction_class<std::remove_volatile>;
using add_cv_mfc = as_metafunction_class<std::add_cv>;
using add_const_mfc = as_metafunction_class<std::add_const>;
using add_volatile_mfc = as_metafunction_class<std::add_volatile>;
using remove_reference_mfc = as_metafunction_class<std::remove_reference>;
using add_lvalue_reference_mfc = as_metafunction_class<std::add_lvalue_reference>;
using add_rvalue_reference_mfc = as_metafunction_class<std::add_rvalue_reference>;
using remove_pointer_mfc = as_metafunction_class<std::remove_pointer>;
using add_pointer_mfc = as_metafunction_class<std::add_pointer>;
using make_signed_mfc = as_metafunction_class<std::make_signed>;
using make_unsigned_mfc = as_metafunction_class<std::make_unsigned>;
using remove_extent_mfc = as_metafunction_class<std::remove_extent>;
using remove_all_extents_mfc = as_metafunction_class<std::remove_all_extents>;
using decay_mfc = as_metafunction_class<std::decay>;
using remove_cvref_mfc = as_metafunction_class<std::remove_cvref>;
using common_type_mfc = as_metafunction_class<std::common_type>;
using underlying_type_mfc = as_metafunction_class<std::underlying_type>;
using result_of_mfc = as_metafunction_class<std::result_of>;
using invoke_result_mfc = as_metafunction_class<std::invoke_result>;
using conjunction_mfc = as_metafunction_class<std::conjunction>;
using disjunction_mfc = as_metafunction_class<std::disjunction>;
using negation_mfc = as_metafunction_class<std::negation>;

}  // namespace cutempl::stdmfc
